1. If the error is an operational error (network partition, hard drive failue, an error that is not an 
application bug) and the function is asynchronous then you deliver the error using a callback and invoking
the callback with the error as the first parameter
2. If you are dealing with a situation where you can have multiple results or multiple errors like for 
instance you are retrieving rows from a database, some might work, some might fail. In that case is better
to deliver the error as an event emitter so the caller must handle the error event
3. If the error is an operation error and the function is synchronous like JSON.parse, you should return the
error synchronously using throw (try/catch) or return the error
4. For a given function, if any operational error can be delivered asynchronously, then all operational 
errors should be delivered asynchronously.
5. The general rule is that a function may deliver operational errors synchronously (e.g., by throwing) or 
asynchronously (by passing them to a callback or emitting error on an EventEmitter), but it should not do 
both.
6. If your function deliver errors through a callback you should throw an error if no callback is passed
to your function

Programmer error: If you get something other than what you’ve documented to accept, that’s a programmer error. 
Operational error: If the input is something you’ve documented to accept but you can’t process right now, 
that’s an operational error.

Another good tip: your functions should be stricter, for instance if you are developing a function that 
takes a IP address argument as a string you should validate the input and reject it in case is invalid
because it could save you from debug time and also you could make your function less strict in the future
if you want but you cannot make your function more strict in the future without breaking backward 
compatibility. Besides you convert the error from an operation error (trying to connect to an IP that is 
not valid) into a programmer error because you explicitly documented that in your function.

Error wrapping information
For example, if an argument was invalid, set propertyName to the name of the property that was invalid and 
propertyValue to the value that was passed. If you failed to connect to a server, use remoteIp to say which 
IP you tried to connect to. If you got a system error, include the syscall property to say which syscall 
failed, and the errno property to say which system errno you got back. See the appendix for example property 
names to use.

Wrap your error to add more information but never to change the original error information
A module used to wrap error information is verror

How to validate parameters in a function
/*
 * Make a TCP connection to the given IPv4 address.  Arguments:
 *
 *    ip4addr        a string representing a valid IPv4 address
 *
 *    tcpPort        a positive integer representing a valid TCP port
 *
 *    timeout        a positive integer denoting the number of milliseconds
 *                   to wait for a response from the remote server before
 *                   considering the connection to have failed.
 *
 *    callback       invoked when the connection succeeds or fails.  Upon
 *                   success, callback is invoked as callback(null, socket),
 *                   where `socket` is a Node net.Socket object.  Upon failure,
 *                   callback is invoked as callback(err) instead.
 *
 * This function may fail for several reasons:
 *
 *    SystemError    For "connection refused" and "host unreachable" and other
 *                   errors returned by the connect(2) system call.  For these
 *                   errors, err.errno will be set to the actual errno symbolic
 *                   name.
 *
 *    TimeoutError   Emitted if "timeout" milliseconds elapse without
 *                   successfully completing the connection.
 *
 * All errors will have the conventional "remoteIp" and "remotePort" properties.
 * After any error, any socket that was created will be closed.
 */
function connect(ip4addr, tcpPort, timeout, callback) {
  assert.equal(typeof (ip4addr), 'string',
      "argument 'ip4addr' must be a string");
  assert.ok(net.isIPv4(ip4addr),
      "argument 'ip4addr' must be a valid IPv4 address");
  assert.equal(typeof (tcpPort), 'number',
      "argument 'tcpPort' must be a number");
  assert.ok(!isNaN(tcpPort) && tcpPort > 0 && tcpPort < 65536,
      "argument 'tcpPort' must be a positive integer between 1 and 65535");
  assert.equal(typeof (timeout), 'number',
      "argument 'timeout' must be a number");
  assert.ok(!isNaN(timeout) && timeout > 0,
      "argument 'timeout' must be a positive integer");
  assert.equal(typeof (callback), 'function');

  /* do work */
}

Be careful try/catch does not work for asynchronous functions. See the test code below
const func = () => {
    return new Promise((resolve, reject) => {
        setImmediate(() => {
            throw new Error('foo');
        });
    });
};


const main = async () => {
    try {
        await func();
    } catch (ex) {
        console.log('will not execute');
    }
};

main();
